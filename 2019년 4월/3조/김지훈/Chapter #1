### 스크럼 vs 폭포수
 
 ## 스크럼 방법론
  - 반복적인 절차(스프린트)를 통해 소프트웨어 제품에 가치를 더한다는 개념을 바탕으로 한다.
  - 제품 백로그(product backlog) 내에 우선순위가 결정
    - 제품 백로그 : 구현되어야 할 기능과 스토리를 정의한다.
  - 스프린트를 시작할 때마다 기간내에 완료해야할 작업들을 선별하여 스프린트 백로그(sprint backlog)를 구성한다.
    - 스프린트 백로그 : 선별된 스토리는 스프린트 백로그로 옮겨진다. 각 스토리는 우선순위에 따라 개발된다.
    - 스프린트 : 1~4주간 진행
  - 변화를 수용하기 위한 코딩
  - 실제로 동작하는 소프트웨어 자체를 가장 중요한 문서로 여긴다.
  
 ## 폭포수 방법론
  - 요구사항 -> 디자인 -> 구현 -> 테스트 -> 배포 -> 유지보수 순의 프로세스
  - 한단계가 완료되면 어떤 오류나 이슈, 문제점들이 발견되지 않는다는 전제
  - 한방향 
  - 변화의 존재를 수용하지 않는다.
  - 문서 중심적
  
  
### 스크럼과 애자일의 문제점
   - 애자일 프로세스는 실패로 치닫고 있는 프로젝트를 성공으로 이끌어 수익을 보장할 수 있는 마법같은 해결책은 아니다.
   
 ## 비적응형 코드
   - 적응력이 떨어지는 코드
   - 변화를 따르기가 어렵다.
   - 코드의 변화가 오래걸리기 때문에 팀이 여러 task에 투입할 노력을 예상할 때 현실과는 동떨어진 예상치가 도출되기도 한다.
   - 코드를 변경하다가 없던 결함이 생겨 이를 해결하기 위해 더많은 시간과 리소스가 낭비된다.
   
 ## 경직성
   - 코드의 경직성은 여러가지 현상으로 표현되며, 이런 현상들을 해결하면 코드의 변경이 계속해서 어려워지고 그로인해 출시 가능한 기능의 개수가 제한되는 결과를 미연에 방지 할 수 있다.
 
 # 추상화의 부재
   - 추상화는 상세한 내용은 숨기고 보다 간소화된 표현을 보여주는 방법이다.
   - 적절한 추상화가 가미된 코드는 훨씬 정리가 잘되며, 다른이와 소통하기에도 좋고, 유지보수도 쉽고, 오류도 적게 발생한다.
 
 # 책임의 혼재
   - 모둔 수준의 코드(메서드, 클래스 및 모듈) 들이 잘 정의된 하나의 책임만을 수행하도록 구현해야 한다.
   
 ## 테스트 불가능
   - 단위테스트는 코드의 올바름을 확인하는 신뢰할 수 있는 방법이다.
   
 # 스카이훅 vs 크레인
   - 코드 내의 스카이훅의 사례 : 정적(static) 메서드, 정적 클래스, new 연산자를 이용한 객체 생성 코드, 확장 메소드 
     이런 요소들은 코드에 모의 객체를 주입하는데 방해가 되므로 테스트를 어렵게 만든다.
   - 크레인으로 대체하여 외부로부터 주입 : 인터페이스, 의존성 주입, 제어의 역전, 팩토리 패턴
   
 ## 지표
   - 소스 코드는 수년에 걸쳐 다양한 지표에 사용되어 왓다. 이들 지표는 각각 소스 코드의 복잡도를 프로젝트 전체의 건전성을 의미 잇는 수준으로 감소시키기 위한 것들 이었다.
   
 # 단위 테스트 커버리지
   - 단위 테스트로 테스트가 가능한 코드의 백분율을 측정하는 것이다.
   - 값의 범위는 테스트 가능한 코드가 없음을 의미하는 0%, 모든 코드가 적어도 하나의 단위테스트를 가지고 있음을 의미하는 100% 사이이다.
   - 최소 80% 커버리지를 최소한 수용 가능한 조건으로 설정하고 있다.
   - 질적 측정과는 달리 단위 테스트의 양을 기준으로 측정한 것이므로 오해의 소지가 있는데, 
     올바른 테스트가 아니라 아무런 테스트나 작성하기만 해도 코드 커버리지가 손쉽게 증가하는 경향이 있기 때문이다.
  
 #순환 복잡도
    - 코드에 존재하는 경로의 숫자를 측정하는 것이다.
    - 순한 복잡도가 증가하면 가지치기한 코드에 대한 단위 테스트 코드 커버리지를 확보하기 위해 필요한 노력 역시 증가하기 때문에 
      순환 복잡도를 낮게 유지하여 추가로 테스트 코드를 작성하지 않도록 하는것이 최선이다.
    - 코드에 가지치기가 많으면 많을수록 더 많은 결함을 내포하게 된다.
     
   