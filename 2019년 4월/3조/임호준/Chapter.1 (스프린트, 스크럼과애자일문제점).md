1. 스프린트
  - 스크럼 프로젝트의 반복되는 작업 주기를 스프린트라고 대부분은 2주 단위로 진행한다.
  - 스프린트 기간이 짧으면 스프린트 목표를 이루기에 시간이 부족할 수 있고, 기간이 너무 길면 팀이 목표를 읽고 방황할 수 있다.
  - 스프린트 제로는 계획을 수립하기 위한 회의를 갖는 것을 목표로 진행된다.
  
  1) 출시 계획 
    - 고객과 제품 소유자가 출시일을 결정하고, 해당 출시 계획에 포함될 기능의 우선순위와 크기를 결정한다. 
    - 기능 예상 : 기능을 개발하기 위해서 어느정도의 노력이 필요한지 예측한다.
    - 기능 우선순위 : 필수 우선순위의 기능은 제품의 출시에 반드시 포함되어야 한다. 선호 우선순위는 시간적 여유가 있으면 포함되어야 할 기능이다.
                    희망 우선순위의 경우 가장 낮은 우선순위를 가지고 있지만 고객은 이 기능이 구현되기를 원한다.
                    
  2) 스프린트 계획 
    - 예상 스토리 포인트를 얻는 과정이다. 
    - 플래닝 포커 : 스토리의 상태적인 크기를 빠르게 예상할 수 있는 방법이고 스토리가 많지 않은 경우 사용한다. 
    - 상대 예측 : 추정해야 할 스토리가 많거나 시간이 부족한 경우 사용한다.
    
  3) 일일 스크럼
    - 몇 시간 전에 회의를 하더라도 스크럼 프로세스 자체는 일일 스크럼 혹은 스탠드업 회의에서만 파악이 가능하다. 
    - 팀은 스크럼 보드 앞에 모여 각 구성원이 순서대로 자신의 상황을 공유한다. 일일 스크럼은 15분을 초과할 수 없다.
    
  4) 스프린트 데모
    - 완료된 스토리가 실제 환경에서 동작하는 것을 보여 주기 위한 회의이다. 개발팀 전체가 참석해야 하며, 임원 및 다른 관련자를 회의에 초대할 수 있다. 
    - 스토리와 관련된 기능을 소개하고 이를 구현하는 과정에서 변경된 기능들을 소개한다. 
    - 데모가 완료된 후에는 사람들이 개별적으로 의견을 말할 수 있는 기회를 제공한다. 
    - 제품 개선을 위한 제안은 제품 백로그에 추가되어 우선순위를 부여하고 일정을 수립할 수 있도록한다.
    
  5) 스프린트 회고
    - 스프린트 데모가 완료되면 작업 주기를 되돌아보고 성공 여부에 대한 의견을 교환한다. 
    - 스프린트 회고의 산출물은 다음 스프린트에도 참조하여 같은 실수가 반복되고 있지 않은지 확인해야 한다.
    
  6) 스크럼 일정표 - 생략
    
2. 스크럼과 애자일의 문제점
  - 애자일 프로세스는 프로젝트를 성공으로 이끌어수 있는 마법 같은 해결책이 아니며, 소프트웨어의 성공적인 출시를 지속하기 위한 것이다.  
  - 단 한 번의 시도로 소비자들의 수요를 충족시킬 수 없으며, 일련의 변화에 탄력적으로 대응하기 위한 적응형 소프트웨어 솔루션을 개발해야 한다.
  
  1) 비적응형 코드
  - 적응력이 떨어지는 코드를 비적응형 코드라고 한다. 결과물을 도출하기 위해, 필요 이상의 시간과 노력, 리소스를 낭비하게 된다.
  - 추상화의 부재 : 자동차가 어떤 원리로 어떻게 움직이는지는 매일 출퇴근길을 운전하는 사람에게는 아주 중요한 정보가 아닌 것처럼,
                    상세 정보는 최대한 많이 숨기고 사용하기에 충분한 정보만을 제공해야 한다.
  - 책임의 혼재 : 손쉽게 분리되지 못하는 코드는 단 몇시간만에 끝낼수 있는 변경사항도 하루 또는 그 이상을 소요하게 한다.
                  이런 형상을 방지하려면 모든 수준의 코드들이 잘 정의된 하나의 책임만을 수행하도록 구현해야한다.
  - 테스트 불가능 : 테스트가 불가능한 코드는 테스트가 되지 않아 결함을 가지고 있을 수 있다. 
    - 스카이훅 (테스트 불가능 요인) - 정적 메서드, 정적 클래스 , New 연산자를 이용한 객체 생성 코드, 확장 메서드
    - 크레인 (해결 방법) – 인터페이스, 의존성 주입, 제어의 역전, 팩토리 패턴
  -	지표 : 소스 코드의 복잡도를 의미 있는 수준으로 감소시키기 위하여 사용한다.
    - 단위테스트 커버리지 : 단위 테스트로 가능한 코드의 백분율 측정한다. 대부분 80%를 최소 수용한 조건으로 설정하고 있다.
    - 순환 복잡도 : 코드에 존재하는 경로의 숫자를 측정한다. 코드를 분기할 때마다 순환 복잡도가 증가하며, 단위 테스트 코드 커버리지를 확보하기 위한 노력 또한 증가한다. 
      순환 복잡도를 낮게 유지하여 추가 테스트 코드를 작성하지 않도록 한다.
