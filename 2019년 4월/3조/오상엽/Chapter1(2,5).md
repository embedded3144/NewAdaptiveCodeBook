# Chapter1
## 역할과 책임
<dd>스크럼은 하나의 프로세스이며, 효율성은 각자가 해당 프로세스를 얼마나 따라주느냐에 따라 결정됨</dd>


### 제품 소유자(Product Owner or PO)
- 최종 제품(결과물)에 대한 오너십과 책임을 가짐  
<dd>

1. 구현할 기능을 결정하는 책임
2. 비즈니스의 가치에 따라 기능의 우선순위를 결정하는 책임
3. 태스크의 완료 여부에 대한 판단을 내리는 책임
</dd>

- 성공의 핵심 이해관계자로서 제품의 비전, 목표, 변화에 대해 팀과 커뮤니케이션 및 공유가 되어야 함

- 소프트웨어의 릴리스에 포함되어야 하는 기능들과 제품 백로그 내의 우선순위 결정

- 스프린트를 진행하는 동안 작업 진행, 스토리 구현, 스프린트 목표, 태스크 수렴 조건 등에 대해서 변경 및 개입이 불가능(개발자가 스프린트의 목표를 이루는 것에 방해가 되면 안됨)  
=> 예외: 스프린트나 프로젝트를 취소하고 완전히 다시 시작하는 경우)

- 개발팀이 스토리를 처리하고 완료하면 해당 기능의 동작에 대한 검증 요구

### 제품 관리자
- 고객 또는 클라이언트와 나머지 개발팀을 연결하는 역할

### 스크럼 마스터
- 스프린트 기간에 외부의 간섭으로부터 팀을 보호, 매일 스크럼 회의를 진행하면서 표시한 방해 요소 제거
- 팀이 스프린트 목표에만 집중하여 최상의 상태로 수행하며 스프린트 기간 내내 생산성 유지에 도움
- 프로세스(결과물)를 어떻게 만들 것인지와 관련된 프레임워크에 대한 오너십을 가짐
  (팀이 프로세스를 따르도록 만듬)
- 권한이 제한적(팀이 스크럼 프로세스를 따르는지를 확인하는 수준에서만 간섭 가능, 기술적 간섭X)

### 개발팀
- 특정 업무가 한사람에게 집중되는 현상 방지  
  => 스크럼에서 코드는 팀 전체의 것이므로 특정 부분이 한사람에게 집중되는 것은 비즈니스 면이나 개발자 개인에게 있어서 좋지 않음
- 소프트웨어 테스터는 개발되는 동안 그 품질을 관리하는 책임  
  => 해당 기능이 요구사항을 만족하는지 검증하기 위해 테스트 자동화에 대해 논의  
  => 테스트 계획 구현을 위해 개발자들과 협업 or 직접 테스트 구현


 ## 스크럼과 애자일의 문제점
 ### 비적응형 코드
 - 적응력이 떨어지는 코드  
   => 코드의 변화가 쉽지 않아 많은 시간과 노력 리소스를 낭비하게 됨


#### 경직성
- 코드의 경직성은 여러가지 현상으로 표현되며, 현상 해결을 통해 코드 변경의 어려움, 출시 가능한 기능의 개수 제한에 대해 방지 가능

1) 추상화의 부재  
   => 추상화는 상세한 내용은 숨기고 보다 간소화된 표현을 보여주는 방법
   => 적절한 추상화가 가미된 코드는 정리가 잘 되며, 소통 및 유지보수에 좋고, 오류가 적음

2) 책임의 혼재  
   => 코드는 작은 것에서 시작해 점점 크고 중요한 것으로 발전하며 임계점에 도달하기 전까지 다른 변화들은 계속 수렴  
   => 임계점이란 지금까지 발생한 변화들로 인해 예측 불가능한 변화들이 초래되는 상황    
   => 코드에 한눈에 식별이 어려운 메서드나 클래스 보유, 각각의 코드가 여러 책임 수행, 코드가 쉽게 분리되지 못함, 코드 변경의 어려움, 예기치 못한 부작용 발생  
   => 현상 방지를 위해 메서드, 클래스 및 모듈들이 하나의 책임만 수행하도록 잘 정의해야 함

#### 테스트 불가능
- 단위 테스트는 코드의 올바름을 확인하는 신뢰할 수 있는 방법이며 테스트가 용이한 코드를 유지하는 것은 지속적인 교육과 노력이 필요
- 테스트가 불가능한 코드는 테스트가 되지 않았다고 볼 수 있음(결함이 있다고 가정)

1) 스카이훅 vs 크레인  
    => 스카이훅 : 코드 테스트를 위한 모의 코드 구현이 어려워 테스트 가능성을 확보하기가 어려워짐  
      1) 정적(static) 메서드
      2) 정적 클래스(싱글턴(Singleton) 객체 포함)
      3) new 연산자를 이용한 객체 생성 코드
      4) 확장 메서드
      
    => 크레인 : 적절한 크레인 대체로 외부로부터 손쉽게 주입되도록 할 수 있음(필요할 때 사용 가능)
      1) 인터페이스(interface)
      2) 의존성 주입(dependency injection)
      3) 제어의 역전(inversion of control)
      4) 팩토리 패턴(factory pattern)
      
#### 지표
- 소스 코드는 다양한 지표에 사용됨, 각각 소스코드의 복잡도를 프로젝트 전체의 건전성(또는 기타 다른 항목)을 의미 있는 수준으로 감소시키기 위한 것들
- SLOC(source Lines Of Code)가 필요한 노력을 측정하는 것과 관련이 있지만 시스템의 기능 수준, 개발자의 생산성 측정과 무관

1. 단위 테스트 커버리지  
=> 단위 테스트로 테스트가 가능한 코드의 백분율을 측정하는 것  
=> 값의 범위는 테스트가 가능한 코드가 없음(0%) ~ 모든 코드가 적어도 하나의 단위 테스트를 가지고 있음(100%)  
=> 단위 테스트 외에 단위 테스트 커버리지 도구도 소스 커밋시 코드를 컴파일하는 지속적 통합 서버에서 실행, 코드 커버리지가 변경될 때마다 빠른 피드백 가능
=> 질적 측정과는 달리 단위 테스트의 양을 기준으로 측정한 것이므로 오해의 소지가 있음

2. 순환 복잡도  
=> 순환 복잡도(cyclomatic complexity)란, 코드에 존재하는 경로의 숫자를 측정하는 것, 코드를 추가로 분기할 때(If문, 루프 등)마다 순환 복잡도가 증가하게 된다.  
=> 순환 복잡도가 증가하면 가지치기한 코드에 대한 단위 테스트 코드 커버리지를 확보하기 위해 필요한 노력 역시 증가(가지치기 할 때 순환 복잡도 낮게 유지)  
=> 가지치기가 많을수록 더 많은 결함 내포 

