# Chapter 2 의존성과 계층화

## Chapter 목적  
* 메서드 수준에서 어셈블리 수준에 이르기까지 복잡한 의존성을 관리한다.
* 의존성 복잡도가 가장 높은 부분을 찾아 이를 해결하기 위한 도구를 사용한다.
* 코드 재사용을보장할 수 있도록 코드를 더욱 잘고 적응이 가능한 조각으로 분리하여 구현한다.
* 계층화 패턴을 유용하게 활용한다.
* 의존성 해석의 개념을 이해하고 의존성 관련 문제를 디버깅한다.
* 간단한 인터페이스를 통해 상세 구현을 숨기는 기법을 익힌다.


## 의존성의 정의 
* 별개의 두 엔티티 사이의 연관 관계로 인해 어느 한 엔티티가(개체) 다른 엔티티의 기능 없이는 자신의 기능을 실행하지 못하는 관계
* 변화를 수용할 수 있는 코드를 작성하기 위해서는 의존성을 효과적으로 관리하여야 한다.

 ### 의존성 3가지
	1.  퍼스트 파티 
		a. Using 만으로는 load 되지 않는다.
		b. 일반적인 dll
	2. 외부 어셈블리(서드파티)
		a. Using 만으로는 load 되지 않는다.
		b. 개발자에 의해 개발된 어셈블리 (FrameWork Extension)
	3. .net Framework
		a. 개발자 의도와는 상관없이 load 된다.
## 서드 파티 의존성 정리
* 공용 참조 dll 폴더를 두고 관리
* 나아가서는 Nuget을 이용한 관리
* CLR(Coomon Language Rwuntime) 공용 언어 런타임 에 모듈 로드 
* 의존성으로 인핸 Test Unit을 생성하기가 어렵다
* 인터페이스 형태로 만들어 의존성을 향상시킨다.
* 인터페이스는 어떤일을 수행할 수있는지를 서술
* 클래스는 어떻게 특정 작업을 수행할 것인지를 서술
* 실제 구현에 대한 상세 내용은 오직 클래스만이 알고 있다. 인터페이스는 해당 작업이 어덯게 수행되는지에 대해 철저히 무관심해야 한다.
* 
## 코드스멜
* New 키워드 사용(객체 인스턴스의 직접적인 생성)
* 생성자는 상세 혀구현이기 때문에 생성자를 이용한다는 것은 클라이언트  코드에 의도하지 않는 의존성을 요구하게 된다,

## 의존선을 해결할 수 있는 코딩
* 인터페 이스를 기초로 한 코딩
	- 실제 구현부분을 인터페이스 뒤로 숨기는것
			- 실체 구현체에 의존하는것이 아닌 인터페이스에 의존하게 만듬
			- 
## 의존성 주입(dependency Injection)
* 구현체를 인터페이스와 분리하여 별도의 어셈블리에 구현하는것
* 올바른 방법은 계단 패턴이다.(Stairway patten) 
* 인터페이스왕 클래스를 서로 다은 어셈블리에 정의함으로써 두 어셈블리를 독립적으로 관리 할 수 있다.
* 다만 이런 의존을 없애기 위해서 수만은 쪼갬이 필요하다.
* 각 클래스는 자신이 의존하는 이터페이스가 정의된 어셈블리만을 참조한다.
* 실제 구현 어셈블리는 묵시적으로도 참조하지 않는다.
* 각 구현 클래스는 자신이 구현할 인터페이스가 정의된 어셈블리를 참조한다.
* 아무런 의존성이 존재하지 않는 인터헤이스, 묵시적 의존성이 존재하지 않는 클라이언트 코드, 오로지 자신이 구현해야할 인터페이스가 정의된 어셈블리만 참조하는 패턴 유지
 
## 의존성 주입의 장점

*  장점
1. Reduced Dependencies 
    * 종속성이 감소한다.
	* components의 종속성이 감소하면 변경에 민감하지 않다.
2. More Reusable Code 
	* 재사용성이 증가한다.
	* 일부 인터페이스의 다른 구현이 필요한 경우, 코드를 변경할 필요없이 해당 구현을 사용하도록 components를 구성할 수 있다.
3. More Testable Code 
	*  더 많은 테스트 코드를 만들 수 있다.
	*  Mock 객체는 실제 구현의 테스트로 사용되는 객체 
		- 종속성을 components에 주입할 수 있는 경우 이러한 종속성의 Mock 구현을 주입할 수 있다.
		- 예를 들어, Mock 객체가 올바른 객체를 반환할 때, null을 반환할 때, 예외가 발생할 때 모두 처리한다.
4. More Readable Code 
	*  코드를 읽기 쉬워진다.
	*  components의 종속성을 보다 쉽게 파악할 수 있으므로 코드를 쉽게 읽을 수 있다.
		
		
## 계층화
	- 소프트웨어 컴포넌트를 각 기능의 수평적 계층으로 취급하고 이들을 바탕으로 전체 애플리케이션을 구성해 나가도록 유도하는 아키텍처 패턴이다.
	  1. 2개의 계층
		a. 사용자 인터페이스 - 데이터 엑세스
	  2. 세 개의 계층
		a. 사용자 인터페이스 - 비즈니스 로직 - 데이터 액세스
    - 횡단 관심사 => aop(관점지향 프로그래밍)
		DB 커넥션 준비
		Statement 객체 준비
		try {
		    DB 커넥션 연결
		    Statement 객체 셋팅
		insert / update / delete / select 실행
		} catch ... {
		예외 처리
		} catch ... {
		예외 처리
		} finaly {
		DB 자원 반납
		}

		빨간색 부분은 공통적으로 나타나는 코드이고 이것을 횡단관심사항
	   파란색 부분은 핵심관심사항

		코드 = 핵심관심사항 + 횡단관심사항

	- 횡단 관심사의 요건들을 정의하고 이들을 캡술화된 기능으로 떼어 내어 적용

	- 비대칭 계층화 - 명령/질의 책임격리(CQRS) - Command/Query Responsibilisy segregation)


## 참고

* 의존성  관리를 위한 디자인 패턴	
1. Observer Pattern
2. Template Method Pattern

*  문제 해결을 위한 디자인 패턴	
1. State Pattern
2. Interpreter Pattern
3. Composite Pattern
4. Strategy Pattern

*  클래스 구조화를 위한 디자인 패턴	
1. Singleton Pattern
2. Proxy Pattern
3. Factory Pattern
	
