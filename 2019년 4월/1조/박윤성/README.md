## 2장. 의존성 계층화

### 프레임워크 의존성
 - 템플릿에 프레임워크별 의존성 관계가 설정되어있음.

### 서드파티 의존성
 - 단일 디렉토리로 관리
 - NuGet 사용

### 안티패턴 
 - 잘 알려졌지만 부정적인 결과나 유연성을 해치는 패턴


### 의존성을 갖는 코드
 - 내부에 New 키워드 사용 : 새로운 객체를 생성함으로 인하여 종속관계 발생
 - 테스트코드가 어렵고 복작해지며 불가능할 수도 있다.

### 의존성 주입
 - 인터페이스를 통해 외부에서 전달받는다.

### 추종자 안티패턴
 - 인터페이스와 구현 클래스는 동일한 어셈블리에 존재하지 않아야한다.
 - 계단 패턴을 통해 분리한다.


### 의존성 해석
 - 참조에 추가된다고 로드되는것은 아니다.
 - using을 사용한다고해서 로드하지 않는다.(실제 사용시 로드됨)
 - .net 기본항목은 참조만으로 로드된다
 - 퍼블리셔정책 -> GAC 검사 -> 디렉터리 탐색 순으로 진행

### RESTFul
 - 의존성 최소화에 가장 매력적임
 - 크로스 플랫폼, 다양한 서비스 지원 가능

### 계층화
- 가장 간단한 방법을 먼저 적용한 후 필요한 경우에만 더 복잡한 방법으로 리펙토링 한다.

- 수직적 확장
  - 하드웨어의 성능을 향상
- 수평적 확장
  - 하드웨어의 수량을 증가

- 2계층 아키텍쳐
  - 약간의 유효성검사제외, 어플리케이션 로직어 거의 없는경우 
  - CRUD만 사용시 간단하게 구현
  - 개념증명, 프로토타입에 적합

- 3계층 아키텍쳐
  - 로직계층 추가, 복잡한 처리 캡슐화
  - 로직계층은 도메인 모델 적용 가능

- 관점지향프로그래밍
  - 코드간섭 최소화하며 기능 적용
  - 트렌잭션을 통한 롤백 구현(라이브러리 사용을 통해 속성오로도 구현가능)

### 비대칭 계층화
- CQS
  - 매서드는 명령(리턴없음), 질의(리턴있음)으로 구분

- CQRS
  - 명령의 트렌텍션 동시성 보장
  - 명령과 질의는 다른 게층에서 실행

## 3장. 인터페이스와 디자인 패턴

### 인터페이스
- 동작을 정의하지만 구현하지 않는다.
- 모든 맴버는 Public이다.
- .net은 다중 상속은 제한하지만 여러개 인터페이스 구현은 허용한다.

- 다이아몬드 상속문제
  - 중복 상속된 함수의 경우 모호성이 발생한다.

- 명시적, 묵시적 구현
  - 명시적 구현시 클래스 인스턴스가 아닌 인터페이스의 인스턴스를 참조해야함.

```cs
    class Program
    {
        static void Main(string[] args)
        {
            C ccc = new C();
            A aaa = ccc;
            B bbb = ccc;

            aaa.Run();
            bbb.Run();
            ccc.Run();
        }
    }

    public interface A
    {
        void Run();
    }
    public interface B
    {
        void Run();
    }
    public class C : A, B
    {
        //묵시적 구현
        public void Run() { Console.WriteLine("Run"); }

        //명시적 구현
        void A.Run() { Console.WriteLine("A.Run"); }
        void B.Run() { Console.WriteLine("B.Run"); }
    }

```

### 널 객체 패턴
- NullReferenceException을 방지하고자한다.
- 클라이언트가 Null 체크를 하지 않도록 한다.

### 어댑터 패턴
- 중간 변환기 역할을 함. 실제구현을 하지는 않고 다른 클래서의 역할을 전달한다.
- 화이트박스 재사용: 재사용 하고자 하는 실제 구현의 수정이 가능하다.
- 블랙박스 재사용: 재사용 하고자 하는 실제 구현의 수정이 불가능하다.

- 클래스 어댑터 패턴
  - 구현상속을 통해 위임한다. 자주쓰이지 않는다.
- 객체 어댑터 패턴
  - 매개션수로 대상 클래스를 전달받고 역할을 전달한다.
- 전략 패턴
  - 실행중 클래스의 동작을 변경하기 위한 패턴

### 인터페이스의 또다른 활용법
- 덕타이핑
  - 실제로 인터페이스를 구현하지 않아도 동일한 기능을 한다면 해당 인터페이스처럼 취급할 수 있다.

```cs
public interface a
{
	void a();
	void b();
}

public class b	//a 인터페이스 구현 안함.
{
	public void a();
	public void b();	
}
```
  - 동적 언어 런타임 활용하기
    - dynamic 키워드 사용하기.
  - Impromptu interface 라이브러리 활용하기
    - Reflection.Emit 메서드 사용한다.
  - CLR의 덕타이핑 지원
    - 단 한가지 경우에만 지원된다. (일반적이지 않음)
    - foreach 에서만 지원된다. (MoveNext, Current)
- 믹스인
  - 상속을 구현하지 않고도 여러 다른 클래스의 구현을 가지고있는 클래스이다.

  - 확장 메서드 사용
    - partial을 사용하지 않더라도 여러 정적 클래스에 걸쳐서 구현한다
    - 정적 클래스라 인스턴스별 관리를 할 수 없다.
  - Re-motion Re-mix 라이브러리 사용
    - ObjectFactory.Create의 리턴을 알 수 없다.
    - is, as 를 통해서 인터페이스를 구현하고있는지 확인해야한다.

### 능동형 인터페이스
- 하나 혹은 그 이상의 메서드들이 인터페이스 자신을 리턴해야한다.
- 가독성을 향상시키거나 상태머신을 구현 할 때 즐겨 사용된다.
- 메서드에 this를 리턴하면 된다.
