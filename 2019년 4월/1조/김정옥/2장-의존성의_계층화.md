2. 의존성의 계층화

1) 의존성의 정의
## 의존성(defendency)의 정의 
  - 별개의 두 엔티티 사이의 연관 관계로 인해 한 엔티티가 다른 엔티티의 기능 없이 자신의 기능을 실행하지 못하는 관계를 의미
  - 엔티티(Entity) : 주로 어셈블리 의미
  - Client : 의존 관계에 있어서 종속적인 엔티티 
  - Service : 의존성을 제공하는 엔티티

  # 의존성
    - First Party : 같은 기반 코드를 이용
    - Third part : 외부 어셈블리  혹은 마이크로소프트 닷넷 프레임워크

  # 호출자 코드로부터 기능을 추상화

  # 의존성 관리 : 순수주의적 접근법을 채택하는 것이 중요

  # 코드 관점(First Party)
    - 전체 코드 : 서비스를 구현하는 코드 혹은 클라이언트를 구현하는 코드
    - 클라이언트 코드 : 클래스 메서드, 어셈블리 등을 호출하는 것
    - 서비스 코드 : 같은 클래스, 메스트 혹은 어셈블리가 다른 메서드, 클래스 및 어셈블리에 의해 호출 되는 것

  # 프레임워크 의존성
    - 프로젝트의 일부는 아니지만 언제든지 활용 가능
    - 닷넷 프레임워크 버전과 동일하게 버전을 가짐  
    - 일부는 이전 버전의 닷넷 프르엠우커를 사용하고 있는 프로젝트에서는 참조가 불가능 할숟 ㅗ 있고
    - 특정 닷넷 프레임워크 버전에만 사용해야 하는 경우도 있음.  

  # 기본 참조 목록
    - 프로젝트 종류에 따라 다르게 프로젝트 템플릿이 존재

  # 서드파티 의존성
  - 개발자에 의해 개발된 어셈블리에 대한 의존성
  - 어떤 기능이나 인프라스트럭처를 직접 구현 하느게 아니라 이미 만들어진 것을 가져와 적절히 활용할 수 있다. 
  - 기존 것을 사용하므로 인해 비지니스 가치에 집중 할 수 있음

  # 서트파티 의존성 정리하기
    - 프로젝트 비주얼 스튜디오 솔루션에 Dependencies 폴더에 .dll 파일을 모아 관리
      ⇒ 모든 외부 의존성릉 소스 제어 저장소에 보관

## 유향 그래프를 이용한 의존성 모델링 
  # 그래프 (Graph)
    - 노드(Node) : 그래프 내의 여러 노드와 연결 될 수 있다. 
    - 엣지(Edge) : 두 노드 사이에만 존재, 노드를 연결 하는 역할
    - 그래프(Graph) : 속성의 변화에 따라 여러 형태 중 한가지
    - 무향그래프(Undirected Graph) : 그래프이 방향이 없다. 
    - 유향 그래프(Directed Graph) / 다이 그래프(DieGraph) : 노드를 향한 방향이 존재

# 노드
  - 프로젝트의 클래스, 서보 다른 어셈블리, 서스시스템을 구성하는 어셈블리 집합 등을 표현 
  - 서브 시스템 안의 어셈블리 - 클래스 - 메서드 ⇒하나의 메스드가 연결된 의존성에 의해 시스템 전체 구성
#화살표 : 두 컴포넌트 사이의 의존성릉 표시
  - 종속적 컴포넌트 : 화살표의 시작 노트
  - 의존성을 제공하는 노트 : 화살표가 가리키는 노트

## 순환 의존성 
  # 순환 다이그래프
    - 방향을 가진 그래프는 순환 형태를 가짐
    - 어셈블리에서는 실제 불가능
    - 비주얼 스튜디오에서는 순환참조로 인해 불가

  # 루프(loop)
    - 순환 다이그래프의 특별한 형태
    - 재귀 호출을 통해 처리

2) 의존성 관리하기
# 패턴(pattern) : 클래스와 인터페이스 사이에서 반복적으로 발생하게 되는 협업들을 규정하여 집대성한 것
# 안티패턴(antipattern) : 유요하지 않는 패턴, 코드의 유연성을 해치기 때문에 사용을 지양

## 구현과 인터페이스의 비교
  # 인터페이스 : 어떤 일을 수횅할 수 잇는지 서술
  # 클래스 : 인터페이스의 구현체, 어떻게 특정 작업을 수행할 것인지 서술 

## new 키워드 코드 스멜
  - 코드 스멜(code smell) : 어떤 코드가 잠재적으로 문제가 있음을 표현
  - 객체의 인스 턴스의 직접적 생성으로 부적절한 결합의 예
  - 생성자는 상세 구현이기 대문에 생성자를 이용한다는 것을 클라이언트 코드에 의도하지 않는 의존성을 요구하게 됨
  - 리팩토링을 통해 해결

# 문제점
  - 구현 향상의 불가능 
  - 의존성 체인 
    . 기본 생성자를 정의함으로써 이 클래스가 어떤 의존성도 갖고 있지 않고 인스턴스가 생성하도록 구현
  - 테스트 가능성의 부재 
    . 이를 위해 코드 자체가 특정방식을 통해 디자인 되어야함 
    . 해당 클래스들이 가지는 의존성을 런타임 시점에 모의 객체로 교체 (Moles/TypeMock 도구 이용)
  - 보다 부적절한 결합
    . 특정 객체의 인터스턴을 얻지 못하면 메서드를 호출 할 수 없음
    . 모든 클래스가 객체를 조회하여 직접 조회

## 객체 생성에 대한 대안
  - 인터페이스를 기초로한 코딩
  - 의존성 주입 기법 활용

## 추종자 패턴(Entourage anti-pattern)
  - 인터페이스와 그에 관련된 의존성을 동일한 어셈블리에 존재해서는 안됨.

## 계단 패턴(Stairway pattern)
  - 인터페이스와 실제 구현 클래스를 서로 다른 어셈블리에 정의
  - 두 어셈블리를 독립적으로 관리
  - 클라이언트는 인터페이스 어셈블리 하나만 참조하게 만듬
    ⇒ 오로지 자신이 구현해야 할 인터페이스 정의된 어셈블리만 참조하는 패턴을 계속해서 이어나가는 구현체를 유지
  - 인터페이스 
    . 어떠한 외부 의존성르 가져도 안됨 
    . 참조하는 서드파트 라이브러리에 정의된 어떤 데이터 객체나 클래스도 속성이나 메서드를 통해 노출 되어서는 아됨
    . 인프라스트럭처ㅇ0ㅔ 관련된 엔티티를 참조하는 것을 피해야함. 

## 의존성 해석하기
  - 어셈블리 
    . 해석프로세스 
    . CLR
  - 퓨전로그(fusion log) 
    . CLR 이 런타임 시점에 실패했던 어셈블리 바인딩을 디버깅하기 위한 도구
  - 서비스
  - 서비스 발견(Service Discovery)   
    . 관리되는 방식(managed) : 서비스 발견 프록시를 호출하는 중앙 서비스는 클라이언트가 이미 알고 있는 서비스, 다른 서비스를 탐색하기 위해 직접 질의를 전달하는 서비스
    . 애드훅 방식(ad-hoc) : 멀티캐스트 네트워크 메세지를 전달, 서비스 발견 프록시가 필요 하ㅓ지 않음.(UDP)

  - RESTful 서비스(REpresentational State Transfer)
    . REST API : 프레임워크와 개발 언어 라이브러리를 공통적으로 제공 

## NuGet을 이용한 의존성 관리
  - 닷넷 프레임워크용 패키지 관리 도구
  - 패키지(package) : 의존성
  - NuGet 패키지 관리자 : 의존성을 추가 가능 
  - 솔루션 루트 폴더 아래의 package/ 폴더에 저장

3) 계층화
  - 컴포넌트 : 두 개 혹은 그 이상의 서로 연관된 어셈블리들이 개발 중인 소프트웨어 시스템 내에서의 형태
  - 어셈블리 동적 링크 라이브러리(DLL, Dynamic Link Libraries) 형태로 배포

# 계층화 
  - 소프트웨어 컴포넌트를 각 기능의 수평적 계층으로 취급하여 전체 애플리ㅋ0ㅔ이션을 구성해 나가도록 유도하는 아키텍처 패턴
  - 컴포넌트는 계층화 되어
  - 어느 하나가 다른 컴포넌트의 상위에 위치할 수 있다
  - 의존성 방향을 항상 아래 방향을 향한다.
  - 최하위 계층은 어떤 의존성도 갖지 않음을 의미한다.
  - 각 계층의 상위 계층은 바로 아래 계층에 대한 의존성을 갖는다.
  - 최상위 계층에는 사용자 인터페이스가 존재

## 일반적인 패턴 
  - 레이어와 티어
    . 레이어(layer) : 논리적으로 구분하는 것
    . 티어(tier) : 물리적으로 구분하는 것
    . 수직적 확장 : 메모리나 프로세스 등을 추가하여 컴퓨터의 성능을 끌어올리는 방법
    . 수평적 확장 : 동일한 작업을 수행하는 또 다른 머신을 추가
  - 두 개의 계층
    . 사용자 인터페이스
    . 데이터 인터페이스 
    . 데이터 액세스 
  - 세 개의 계층
    . 사용자 인터페이스
    . 비지니스 로직 : 사용자 인터페이스 게층으로부터 명령 처리 / 비지니스 도메인을 모델링하여 비지니스 프로세스, 규칙 업무 흐름을 정의
    . 데이터 액세스

## 횡단 관심사(cross-cutting concerns)
  - 관점의 요건을 정의하고, 캡슐화된 기능으로 떼어 내어 코드에 적용하여 코드 간섭을 최소화하면서 기능을 적용하는 방법
  - 관점지향 프로그래밍(AOP, Aspect-Oriented Programinin) : 관점을 코드 내의 여러 계층에 적용하는 방법

## 비대칭 계층화(asymmetric layering)
  # 명령/질의 책임 격리 패턴 (CQRS, Command/Qurey Resopnsibility Segreation)
    - 명령 
      . 동작을 위해 의무적으로 호출 해야 하는 것 
      . 코드로 하여금 필요한 작업을 실행하게 함
      . 값을 리턴
    - 메소드
      . 시스템의 상태를 변경
    - 질의 
      . 데이터에 대한 요청
      . 자신을 호출한 클라이언트에게 데이터를 리턴
      . 시스템의 상태를 변경하서는 안됨
  # 명령/질의 책임 격리(CQRS)
    - 그렉 영에 의해 정립
    - CQS 패턴을 아키텍처 수준으로 적용
    - 비대칭 게층화의 예
    - 명령과 질의는 각각을 가장 잘 처리할 수 있는 게층화의 경로로 따를 필요가 있다는 점을 함께 고려
    - 도메인 모델을 바탕으로 3계층 아키텍처를 구현할때 적용 가능 
    - 도메인 모델은 애플리케이션 명력 측 영역에서만 사용
    - 질의 영역에서 보다 단순한 2게층 모델이 사용
    - 데이터에 대한 질의 
      . 빠르게 수행되어야 함
      . 트랜잭션 동시성에 대한 보장이 필요치 않다
      . 응답성 향상을 위해 팬텀 읽기 / 밙고하지 않는 읽기를 허용 가능
    - 명령에 대한 처리 
      . 트랜잭션 동시성이 보장되어야 함.
      . 명령과 질의의 처리는 서로 다른 계층을 통해 실행 되어야 함
      . 경우에 따라 데이터 액세스 계층 역시 명령과 질의에 따른 다른 계층 사용 가능
      . 명령 : ACID를 완벽히 지원하는 DB 사용
      . 질의 : 간단한 도큐먼트 저장소를 사용할 수 있다. 
      . 도큐먼트 저장소 : 명력 측 영역에서 발생한 이벤트에 의해 비동기적으로 업데이트 되어 질의 측 영역에 최종적 일관성을 적용
