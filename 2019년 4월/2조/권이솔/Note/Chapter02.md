# Chapter 2 의존성과 계층화
의존성은 충분한 학습과 이해를 통해 쉽게 관리될 수 있다.
단기적으로는 애플리케이션을 잘 정리할 수 있도록 도와주는 패턴을 적용하여, 
장기적으로 변화를 수용할 수 있는 코드를 완성해 나가면 된다.
## 의존성의 정의
의존성(dependency)은 별개의 두 엔티티(entity, 개체) 사이의 연관 관계로 인해 어느 한 엔티티가 다른 엔티티의 기능 없이는 자신의 기능을 실행하지 못하는 관계를 의미한다.
- 퍼스트파티(first-party) 의존성 : 프레임워크 의존성
- 서드파티(thrid-party) 의존성 : 개발된 어셈블리에 대한 의존성
  - 서드파티 의존성 정리하기 :  해당 프로젝트의 비주얼 스튜디오 솔루션에 Dependencies라는 이름의 폴더를 만들어 두고 여기에 모든 .dll 파일들을 모아 두는 것이다.
- 유향 그래프를 이용한 의존성 모델링
  그래프는 소프트웨어 엔지니어링의 다양한 분야에서 모델링 도구로서 훌륭히 그 역할을 하고 있지만, 코드 의존성의 모델링에도 매우 적합하다.
  엔티티를 노드라고 생각하면 종속적은 코드에서 의존성을 제공하는 코드로 방향이 있는 엣지를 그릴 수 있다.
  이 방법으로 엔티티들을 그려 나가면 그것이 바로 의존성 다이그래프(dependency digraph)가 되는 셈이다.
## 의존성 관리하기
의존성을 제대로 관리하지 못하면 사소한 문제점이 얼마 지나지 않아 아키텍처 전체의 문제점으로 커질 수도 있다.
- new 키워드의 코드 스멜 
  - 인터페이스는 어떤 일을 수행할 수 있는지를 서술하며, 클래스는 어떻게 특정 작업을 수행할 것인지를 서술한다.
  - new 키워드를 사용한다는 것은 코드 스멜(code smell)로 취급할 수 있다.
  - 구현 향상이 불가능, 의존성 체인, 테스트 가능성의 부재, 부적절한 결합
- 객체 생성에 대한 대안
  - 인터페이스를 기초로 한 코딩
  - 의존성 주입 기법 활용
- 추종자 안티 패턴(Entourage anti-pattern)
추종자 안티패턴은 뭔가 단순한 것을 요구했는데 관련된 모든 것들이 뒤따라오는 상황에서 비롯된 이름이다.
인터페이스와 그에 관련된 의존성들은 동일한 어셈블리에 존재해서는 안 된다.
- 계단 패턴(Stairway Pattern)
  - 인터페이스와 실제 구현 클래스를 서로 다른 어셈블리에 정의함으로써 두 어셈블리를 독립적으로 관리할 수 있고, 클라이언트는 인터페이스 어셈블리 하나만 참조하도록 설계한다.
  - 프로젝트의 수는 늘어나겠지만 잘 정리되고 이해하기 쉬운 구조의 솔루션을 갖게 된다는 이점이 있다.
  - 인터페이스는 어떠한 외부 의존성도 가져서는 안된다.

### 의존성 해석하기
### Nuget을 이용한 의존성 관리

## 계층화(Layering)
계층화는 소프트웨어 컴포넌트를 각 기능의 수평적 계층으로 취급하고 이들을 바탕으로 전체 애플리케이션을 구성해 나가도록 유도하는 아키텍쳐 패턴이다.
- 일반적인 패턴
가장 간단한 방법을 먼저 적용한 후 필요한 경우에 더 복잡한 방법으로 리팩토링 한다.
  - 두 개의 계층

### 횡단 관심사
감사나 보안 그리고 캐시 등은 모든 계층에 사용되기 때문에 애플리케이션 전체에 적용되어야 한다.
횡단 관심사의 요건들을 정의하고 이들을 캡슐화된 기능으로 떼어 내어 코드에 적용하면 코드에 대한 간섭을 최소화할 수 있다.
- 관점지향 프로그래밍(AOP, Aspect-Oriented Programming)은 횡단 관심사를 코드 내의 여러 계층에 적용하는 방법이다.
### 비대칭 계층화
- 명령/질의 분리(CQS) : 시스템의 상태를 변경할 수는 있지만 값을 리턴해서는 안된다.
- 명령/질의 책임 격리(CQRS)  
