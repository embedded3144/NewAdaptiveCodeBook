# Chapter 1 스크럼을 소개합니다.
## 스크럼 vs 폭포수
- 폭포수 프로세스는 변화를 허용하지 않는다. 변화는 항상 존재하므로 말이 되지 않는다.
- 애자일은 변화를 받아들이고 변화가 발생하면 어느 누구라도 이를 수용할 수 있도록 허용한다.

## 역할과 책임
- 제품 소유자(PO, Product Owner)
  * 최종 제품에 대한 오너십을 가지며 구현할 기능을 결정하는 책임, 비즈니스의 가치에 따라 기능의 우선순위를 결정하는 책임, 태스트의 완료 여부에 대한 판단을 내리는 책임을 가진다.
  * 스프린트가 진행되면서 개발팀이 스토리를 처리하고 완료하면, 제품 소유자는 해당 기능이 어떻게 동작하는지 검증을 요구하거나 진행중인 태스크에  댓글을 작성할 수 있다.

- 스크럼 마스터(SM, Scrum Master)
  * 스크럼 마스터는 스프린트 기간에 외부의 간섭으로부터 팀을 보호하며, 팀이 매일 스크럼 회의를 진행하면서 표시해 둔 모든 방해요소를 제거하는 역할을 담당한다.
  * 결과물을 어떻게 만들 것인지와 관련된 프레임워크에 대한 오너십을 갖는다.
  * 스크럼 마스터는 팀이 스토리를 구현하는 과정이 스크럼 프로세스를 따르는지를 확인하는 수준에서만 간섭할 수 있을 뿐 기술적으로 간섭해서는 안 된다.
  * 스크럼 마스터는 팀이 회의에 참여할 수 있도록 독려하며, 해야 할 일이 처리되지 못하고 있지는 않은지 집중적으로 파악한다.
  
- 개발팀
  * 이상적인 상황이라면 애자일 팀은 평준화된 전문가(Generalizing Specialist)들로 구성된다.
  * 팀이 다양한 기술을 갖춤으로써 애플리케이션의 일부에 대한 지식을 한 사람이 독점하는 상황을 방지할 수 있다.
  * 가능하다면 특정 업무가 한 사람에게 집중되는 현상을 방지하도록 해야 한다.

## 산출물
- 스크럼 보드(Scrum board)
  * 
## 스프린트
반복되는 작업 주기를 스프린트(Sprint)라고 한다. 대부분 2주 단위로 진행한다.
- 출시 계획
  * 기능 예상, 기능 우선순위
- 스프린트 계획
  * 플래닝 포커(Planning poker) : 제픔 백로그에 나열된 모든 사용자 스토리에 간략한 설명을 한 후 모든 사람이 해당 스토리에 어느 정도의 스토리 포인트를 할당할 것인지를 투표한다.
  * 상대 예측(Affininty Estimation) : 플래닝 포커의 반대 개념으로 소개된 것인데, 작업할 스토리의 개수가 많은 경우 투입해야 할 시간의 양을 예상하는 방법니다.
- 일일 스크럼
  * 어제 진행한 업무는 무엇인가? 
  * 오늘 진행할 업무는 무엇인가? 
  * 현재 당면한 방해 요소는 무엇인가?
- 스프린트 데모(Sprint demo)
  * 완료된 스토리가 실제 환경에서 동작하는 것을 보여주기 위한 회의이다.
- 스프린트 회고(Sprint Retrospective)
  * 지난 스프린트에서 우리가 잘했던 일은 무엇인가?
  * 지난 스프린트에서 우리가 개선해야 할 점은 무엇인가?
  * 앞으로 새로 시작해야 할 일은 무엇인가?
  * 앞으로 지양해야 할 일은 무엇인가?
  * 앞으로도 계속해야 할 일은 무엇인가?
  * 스프린트 기간에 예상하지 못했던 일이 발생한 적이 있었나?

## 스크럼과 애자일의 문제점
모든 소프트웨어 개발 프로세스의 목표는 소프트웨어의 성곡적인 출시를 지속하기 위한 것일 뿐, 소프트웨어가 저절로 만들어지게 하는 건 아니다.
적응형 소프트웨어란, 모든 소프트웨어가 당면하게 되는 일련의 변화에 탄력적으로 대응 할 수 있음을 의미한다.

- 비적응형 코드
  - 적응력이 떨어지는 코드를 비적응형(Maladaptive) 코드라고 한다. 코드의 적응력이 떨어지면 변화를 따르기가 쉽지 않게 된다.
  - 경직성 : 추상화(Abstraction)의 부재, 책임의 혼재
  - 테스트 불가능 : 스카이훅(skyhook) vs 크레인, 지표
    - 스카이훅 : 정적(static) 메서드, 정적 클래스(싱글턴(Singletor) 객체 포함), new 연산자를 이용한 객체 생성 코드, 확장 메서드(extension method)
    - 크레인 : 인터페이스(interface), 의존성 주입(dependency injection), 제어의 역전(inversion of control), 팩토리 패턴(factory pattern)
  - 지표(metrics)
    - 단위테스트 커버리지