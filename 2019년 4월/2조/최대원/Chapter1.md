## 스크럼을 소개합니다.
- 애자일 방법론 중 하나
- 반복적인 절차를 통해서 제품에 가치를 더하는 것
- 반복되는 과정은 스프린트
- 스크럼의 작업 단위는 스토리

### 1. 스크럼 vs 폭포수

- **폭포수 개발 프로세스**

![1-1](image\1-1.jpg)

- 변화는 불필요하며 **회피할 수 있는 개념** 이라고 본다.
- **스크럼 개발 프로세스**

![1-2](image\1-2.jpg)

- 변화를 받아들이며 **변화를 수용하기 위한 코딩** 을 허용한다.

### 2. 역할과 책임

- **제품 소유자**
  - 구현할 기능을 결정한다.
  - 비즈니스 가치에 따라 기능의 우선순위를 결정한다.
  - 태스크(task)의 '완료 여부'에 대한 판단을 내린다.
  - 작업의 진행등에 대해 무한한 영향력을 행사할 수 없다.
- **스크럼 마스터**
  - 팀의 모든 방해 요소를 제거하는 역할
  - 결과물을 어떻게 만들것인가에 관한 오너십을 가짐
  - 매일 스크럼 회의를 주재한다.
- **개발팀**
  - 여러 분야에 전문성을 가지고 있어야 한다.
  - 한 가지 역할만을 강조하는 것은 모두에게 좋지 않다.
  - 테스터는 제품이 개발되는 동안 그 품질을 관리하는 책임을 가짐.
- **돼지와 닭**
  - 달걀을 제공하는 닭 : 고객(기여)
  - 햄을 제공하는 돼지 : 제품 소유자, 스크럼 마스터, 개발팀 (직접 관련)

### 3. 산출물

- 스크럼의 문서는 프로젝트 성공을 위해 반드시 필요한 것 이외를 제외
- 대신 코드로 문서를 대신함

- **스크럼 보드**

  ![1-3](image\1-3.jpg)

  - 카드
    - 아주 작은 태스크부터 물리적인 소프트웨어 릴리스까지 제품의 진도를 나타내는 개별적 요소
    - 카드의 종류는 색상이나 채도로 표현
    - 현재 스프린트와 연관된 스토리, 작업, 결함 및 기술부채만을 표현
  - 제품
    - 모든 과정의 최상위인 구현해야 할 소프트웨어 제품
  - 릴리스
    - 소프트웨어의 버전
  - 기능
    - 소프트웨어 제품을 구성하는 요소
    - 고객에게 가치를 제공할 수 있는 가장 작은 크기의 기능 : 최소 시장성 기능
    - 우선순위에 따라 필수, 선호, 바람으로 구분됨
  - 사용자 스토리
    - 정의 : [사용자 역할]로서, 나는 [행위]를 함으로써 [사용자에게 제공할 가치]를 얻고자 한다.
    - 어떤 기능을 구현해야 할지는 상세하게 표현하지 않음
    - 분석 단계에서 요구 사항 수집 후, 디자인을 구상하고 구현 - 폭포수 모델의 축소판
    - 스토리마다 인센티브인 스토리 포인트가 존재한다.
  - 태스크
    - 사용자 스토리보다 작은 작업 단위
    - 특정 기능을 구현하기 위해 개발자에게 할당된다.
    - 수직적 분할 :  각 사용자 스토리는 각 계층에 필요한 모든 기능을 인터페이스 계층과 연동(애자일)
    - 수평적 분할 :  각 계층을 맡아서 전체에 요구되는 기능을 구현
  - 기술 부채
    - 이상적인 코드와 마감일을 맞추는 충분한 수준의 코드의 타협점
    - 향후에 개선점을 두고 당장 간단하게 해결하는 방법.
    - 좋은 기술 부채 : 합당한 이유로 생성되었고 회피할 대안을 알고 있는 부채
    - 나쁜 기술 부채 : 무분별하게 생성되거나 대안을 모르는 부채
    - 기술 부채 상환 : 스토리 포인트와 무관하지만 상환해야 하기에 다음 추가 스토리에 부채를 부착하여 코드를 리팩토링하여 새로운 동작에 관한 디자인을 구현한다.
  - 결함
    - 이미 완료된 사용자 스토리가 조건을 만족하지 못했을 때 생성됨
    - 향후 작업에 영향을 끼치지 않는 테스트 세트 형태로 작성
    - 스토리 포인트를 가지지 않음
    - 심각한 결함 : 애플리케이션이 완전하게 실패하거나 작업을 계속할 수 없는 결함, 우선순위 상
    - 행위 오류 : 로직의 문제, 충돌의 문제, 우선순위 중
    - 표현 이슈 : 외관상의 문제, 우선순위 하
  - 스윔레인
    - 스크럼 보드에서 선으로 구분한 것
    - 백로그 레인 : 특정 스프린트에 진행하는 것으로 승인된 것. 작업을 시작할 때 스토리 보드에서 떼어야 하며 우선 순위에 따라 맨 위에서 부터 먼저 구현해야 함
    - 진행 중 레인 : 백로그에서 제품 소유자와 기능의 범위, 요구 사항의 대화 후 스토리를 진행 중 레인으로 옮김, 팀 전원이 스토리를 진행하게 됨.
    - 완료 레인 : 스토리 분석과 디자인, 구현이 완료되면 QA 레인으로 옮겨지고 모든 것이 완벽하게 완료되면 완료 레인으로 옮겨 스토리에 할당된 모든 스토리 포인트를 획득함.
    - 수평 스윔레인 : 스토리를 기능 단위로 그룹화하여 팀의 역량의 집중을 파악하기 위함. 맨 위에는 가장 높은 우선순위 태스크를 나열함. 
  - 디지털 스크림 보드
    - 벽에 매달지 않으면 프로젝트에 대한 매우 중요한 정보를 보여주지 못함.
    - 사용하기에 불편해진다면 관심을 끌지못하고 빠르게 뒤쳐질 것
  - 완료에 대한 정의
    - 완료에 대한 정의를 모두가 동의해야 완료 상태가 될 수 있음
    - 코드 실행의 성공 및 실패의 경우를 모두 커버하는 단위 테스트를 작성해, 모든 테스트가 실패없이 통과해야 함
    - 모든 코드는 지속적 통합 서버에 전달되어 오류 없이 빌드 및 컴파일되며 모든 테스트를 통과해야함
    - 제품 소유자와 함께 수렴 가능한 제품의 동작을 검증한다.
    - 해당 스토리에 참여하지 않은 개발자와 짝을 이루어 코드를 리뷰한다.
    - 의사소통에 필요한 만큼만 문서를 작성한다.
    - 무분별한 기술 부채를 해결한다.

- **차트와 측정**

  - 차트를 통해서 진척도를 모니터링한다.

  - 역량을 평가하기 위한 것이 아닌 전체 프로젝트의 문제점을 분석하기 위한 것임.

  - 스토리 포인트

    - 매 스프린트에 비즈니스 가치를 부여하여 팀을 독려하기 위한 장치
    - 특정 기능을 구현하는데 필요한 상대적인 노력(시간)의 정도
    - 스토리 포인트는 팀 내부적인 기준에 따라 다를 수 있음

  - 속도

    - 스프린트를 진행하다보면 평균적인 스토리 포인트로 속도 계산 가능
    - 다음 스프린트에 팀이 커밋해야 할 포인트의 한계치
    - 속도가 떨어지는 것은 해결해야 할 문제가 생겼다는 것을 의미함.

  - 스프린트 번다운 차트

    ![1-4](image\1-4.jpg)

    - y축은 총 스토리 포인트, x축은 총 업무일수를 표시한다.
    - 이상적인 진척도를 대각선으로 그리고, 매 회의마다 획득한 스토리포인트를 뺀 그래프를 그린다.
    - 실제 진척선이 더 높으면 계획보다 늦어지고 있다는 것
    - 실제 진척선이 더 낮으면 계획보다 빠르게 이뤄지고 있다는 것

  - 기능 번업 차트

    ![1-5](image\1-5.jpg)

    - 기능의 완료도를 표시하는 차트
    - 시간이 흐르는 동안 정체현상 없이 지속적으로 증가해야  함.
    - 코드가 변화를 수용하지 못할 경우 점점 정체됨 (리팩토링이 필요함)

- **백로그**

  - 아직 시작되지 않은 대기 작업들의 목록
  - 제품 백로그
    - 제품의 개발주기동안 구현해야 할 기능들을 포함함
    - 개발팀은 순위를 부여하고 정리해 둘 수 있음
    - 같은 가치의 기능이라면 상대적으로 작은 기능이 우선순위가 높다. (투자 수익률이 높음)
    - 결함 또한 비즈니스적 가치를 갖는다.
    - 누구나 볼 수 있으며 권위가 있어야 하고 실제 상황을 반영해야 한다.
  - 스프린트 백로그
    - 해당 스프린트 내에 완료해야 할 모든 사용자 스토리를 관리한 것
    - 팀의 현재 속도와 개발해야 할 사용자 스토리의 상대적 크기를 고려하여 스프린트 백로그를 채움

### 4. 스프린트

- 스크럼 프로젝트의 반복되는 작업 주기로 대부분 2주간 진행한다.
- 스프린트는 인덱스 번호로 구분하며 zero부터 시작한다.
- 스프린트 제로에서는 스프린트 시작하기에 앞서 주요 계획을 수립하기 위한 회의를 갖는 것이 목표다.
- **출시 계획**
  - 고객과 제품 소유자가 출시일을 결정하고 기능의 우선순위와 크기를 결정한다.
  - 기능 예상
    - 기능의 구현에 필요한 노력은 티셔츠 크기로 표현한다 ex) XL, L, M, S, XS
  - 기능 우선순위
    - 필수 : 출시에 반드시 포함되어야 할 기능
    - 선호 : 작업 마감일 이전에 시간적 여유가 있다면 출시에 포함해야 할 기능
    - 희망 : 이번 출시에 포함되지 않지만 고객들이 원하고 있는 기능
- **스프린트 계획**
  - 회의를 통해 예상 스토리 포인트를 얻어야 한다.
  - 플래닝 포커
    - 스크럼 마스터와 제품 소유자를 포함한 전체 개발팀이 참여한 투표를 실시한다.
    - 포인트간의 근소한 차이가 발생하는 것을 피하기 위해 점수를 제한하는 것이 좋다.
    - 평균값에서 크게 벗어나는 사람은 평균값의 견해를 기준으로 조정하는 것이 좋다.
    - 합의가 이루어질때까지 토론을 반복한다.
  - 상대 예측
    - 제품 백로그 맨 위부터 둘 중 어느것이 더 작은 것인지 비교하고 구분하여 놓는다.
    - 스프린트기간에 수행할 수 있는 모든 스토리를 구분한 후 피보나치 수열을 수정한 값으로 포인트를 할당한다.
    - 스토리가 많거나 시간이 적을 때 유용한 방법이다.
- **일일 스크럼**
  - 스크럼 프로세스는 일일 스크럼과 스탠드업 회의에서만 파악이 가능하다.
  - 15분을 초과할 수 없고 세가지 질문에만 답변한다.
    - 어제 진행한 업무는 무엇인가?
    - 오늘 진행할 업무는 무엇인가?
    - 현재 당면한 방해 요소는 무엇인가?
  - 대화가 주제에서 벗어나지 않도록 하는 것이 중요하다. 회의가 끝난 후 적절한 사람과 논의한다.
- **스프린트 데모**
  - 완료된 스토리가 실제 환경에서 동작하는 것을 보여주기 위한 회의이다.
  - 전체 개발팀이 참석해야 하며 관련자, 누구나 참석하게 하여 개방성을 조성한다.
  - 스토리와 관련된 기능을 소개하고 실제 환경에서 기능을 사용하는 데모를 진행한다.
  - 프로젝트의 완료 조건을 피한 데모를 취하는 경우가 있어선 안된다. 대신 차트와 수치로 원인을 설명한다.
- **스프린트 회고**
  - 성과가 좋아 반복해야 할 일과 문제를 잘 처리한 일을 선별하는 데 도움이 된다.
  - 팀이 고려해야 할 질문은 다음과 같다.
    - 지난 스프린트에서 잘했던 일은?
    - 지난 스프린트에서 개선할 점은?
    - 앞으로 새로 시작해야 할 일은?
    - 앞으로 지양해야 할 일은?
    - 앞으로 계속해야 할 일은?
    - 예상하지 못했던 일이 발생한 적이 있는가?
  - 문제의 해결책을 찾는것이 중요하며 생산적이고 정중하게 비평에 임해야한다.
  - 이 회의의 산출물은 잊어버리면 안되며 지속적으로 행동에 옮겨야한다.
  - 스토리 포인트 삼각법
    - 스프린트 기간에 진행된 스토리중 팀이 예상했던 것과 다른 노력이 투입될 수 있다.
    - 실제 투입 노력과 예상 투입 노력의 차이가 크다면 예측이 잘못된 것이라고 볼 수 있다.
- 스크럼 일정표
  - 스프린트를 끝낼 때와 시작 할 때는 거의 하루종일 회의가 이루어진다.
  - 일일 스크럼이 너무 빠르면 참석자가 늦을 수 있고, 너무 늦으면 일에 몰두하는 사람을 방해할 수 있다.
  - 모든 사람들이 참석하도록 독려해야한다.

### 5. 스크럼과 애자일의 문제점

- **비적응형 코드**

  - 코드의 적응력이 떨어지면 태스크의 노력을 예상할 때 현실과 동떨어진 예측을 할 수 있다.

  - 경직성

    - 추상화의 부재 : 상세한 내용은 숨기고 간소화 된 표현을 보여주는 방법인 추상화를 쓰지 않는다면 정리가 안되고, 다른 이와 소통이 힘드며, 유지보수도 어렵고, 오류도 많이 발생한다.
    - 책임의 혼재 : 각각의 코드가 여러가지 책임을 수행하여 손쉽게 분리되지 못하는 형태로 작은 변경 사항도 하루 또는 그 이상을 소요할 수 있다.

  - 테스트 불가능

    - 테스트가 되지 않는 코드는 결함을 가지고 있을 수 있다.
    - 스카이훅이 있는 코드는 테스트가 힘들고 크레인은 테스트하기 쉽다.
    - 스카이훅은 아무런 동기도 없는 기계화의 결과이다. ex)정적 메서드, 정적 클래스, new, 확장 메서드
    - 크레인은 설계 프로세스의 하위 프로세스 혹은 특별한 기능이다. ex)인터페이스, 의존성 주입, 제어의 역전, 팩토리 패턴

  - 지표

    - 소스 코드의 복잡도를 의미 있는 수준으로 감소시키기 위한 것이다.
    - 단위 테스트 커버리지 : 테스트가 가능한 코드의 백분율을 측정하는 것으로 최소 80퍼센트의 커버리지를 수용 가능한 최소조건으로 설정하고 있다.

    ![1-6](image\1-6.jpg)

    - 순환 복잡도 : 코드에 존재하는 경로의 숫자를 측정하는 것으로 if, 루프, switch등 분기할 때마다 순환 복잡도가 증가하게 된다. 복잡도가 증가하면 가지치기한 코드의 커버리지를 확보하기 위해 필요한 노력이 증가하고 더 많은 결함을 가질 가능성도 증가한다.

    ![1-7](image\1-7.jpg)